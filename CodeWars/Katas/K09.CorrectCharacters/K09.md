Character recognition software is widely used to digitise printed texts. Thus the texts can be edited, searched and stored on a computer.

When documents (especially pretty old ones written with a typewriter), are digitised character recognition softwares often make mistakes.

Your task is correct the errors in the digitised text. You only have to handle the following mistakes:

S is misinterpreted as 5
O is misinterpreted as 0
I is misinterpreted as 1
The test cases contain numbers only by mistake.

游

1. Buscar un m칠todo para sustituir 
String.prototype.replace()

2. He tratado de resolverlo con el loop y sustituir. X


function correct(string)
{
var modifiedString;
  
  for ( let i = 0; i.length >= string; i++) {
    if ( i === 5 ) {
      modifiedString = string.replace("5","S")
    } else if ( i === 0 ) {
      modifiedString = string.replace("0","O")
    } else if ( i === 1) {
      modifiedString = string.replace("1","I")
    } else {
      return string;
    }
  }
  return modifiedString;
}

游 Problemas clave

Condici칩n del for:
i.length >= string est치 mal. i es un n칰mero, no tiene .length. Deber칤as recorrer string.length.

Reemplazo incorrecto:
string.replace("5", "S") solo reemplaza la primera coincidencia. Y t칰 llamas replace() con la string original cada vez, sin ir acumulando los cambios.

Comparas i === 5, i === 0, etc., pero i es un n칰mero de 칤ndice, no el car치cter de la cadena. No sirve para saber qu칠 car치cter hay.

No vas acumulando cambios en modifiedString car치cter por car치cter.

CORRECCI칍N:

function correct(string) {
  let modifiedString = "";

  for (let i = 0; i < string.length; i++) {
    let char = string[i];

    if (char === "5") {
      modifiedString += "S";
    } else if (char === "0") {
      modifiedString += "O";
    } else if (char === "1") {
      modifiedString += "I";
    } else {
      modifiedString += char;
    }
  }

  return modifiedString;
}

Nota:

modifiedString += "O";
No suma al n칰mero original.

No a침ade el car치cter reemplazado despu칠s del original.

Directamente lo reemplaza por el car치cter correcto (a침adiendo el bueno a la nueva cadena y no el malo)

3. El primer test es "L0ND0N" -> as칤 que he probado en sustituir el 0, pero con string.replace("0","O") , s칩lo sustituye la primera. 
-> en la documentaci칩n aparece esto: 
A string pattern will only be replaced once. To perform a global search and replace, use a regular expression with the g flag, or use replaceAll() instead.

function correct(string)
{ 
  const re = /0/gi;
  
  const newString = string.replace(re,"O");

  return newString;
 
  
}
Esto funciona para LONDON, pero para el resto ya no. 

4. Encontr칠 c칩mo hacerlo en la respuesta a una pregunta en un foro
https://stackoverflow.com/questions/16576983/replace-multiple-characters-in-one-replace-call



Documentaci칩n: 

- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace


游눬 Exlicaci칩n: 

- 1. const chars = { '0': 'O', '5': 'S', '1': 'I' }
Esto es un objeto que funciona como un "diccionario" o "tabla de reemplazo":

La clave es el car치cter err칩neo.

El valor es el car치cter correcto.

As칤, chars['0'] devuelve 'O'.


2. string.replace(/[051]/g, m => chars[m])
Aqu칤 viene lo interesante. Vamos a desglosarlo:

a) /[051]/g
Los corchetes [] indican una lista de caracteres individuales.

En este caso: busca todos los caracteres que sean 0, 5 o 1.

La g es la bandera global (global flag): le dice a .replace() que no se detenga en el primer reemplazo, sino que siga buscando en toda la cadena.

b) m => chars[m]
Esto es una funci칩n flecha. Aqu칤:

m es una variable que representa el car치cter que coincide con la expresi칩n regular.

chars[m] busca en el objeto chars el reemplazo correspondiente.

Es decir:

Si m = '0', entonces chars['0'] = 'O'

Si m = '5', entonces chars['5'] = 'S'